package com.yijian.javabase.base.运算符;

/**
 * @author: yxyaojinhua
 * @date: 2021/10/26 15:30
 * @description: 位运算符 (二进制运算)
 *
 *    &：位与运算符
 *    |：位或运算符
 *    ^：异或运算符 特点: 一个数据对另一个数据异或两次 改数据本身不变  a^b^b = a
 *    ~：取反运算符
 *    <<：左移运算符 最高位丢弃，右边补0
 *    >>：右移运算符 最高位是0，左边补0，最高位是1，右边补1
 *    >>>：无符号右移 无论最高位是1还是9 左边补0
 */
public class BitOperator {
    /**
     * 补充知识点1：原码，反码，补码(正数的原反补都相同)
     *    1).底层都是用补码进行计算的
     *    2). int i = 7;
     *     原码：
     *         正数的原码最高位是0，负数的最高位是1，其他都是数值数
     *             符号位   数值位
     *     +7      0        0000111
     *     -7      1        0000111
     *     反码：
     *        正数的反码与原码相同
     *        负数的反码与原码符号位相同，数值位去反 1变0，0变1
     *             符号位   数值位
     *     +7      0        0000111
     *     -7      1        1111000
     *    补码：正数的反码与原码相同，负数的补码在反码的基础上加1
     *             符号位   数值位
     *     +7      0        0000111
     *     -7      1        1111001
     *  补充知识点2:
     *     二进制：由1和0组成。以0b开头 system.out.println(0b1111);
     *     八进制：由0,1....7组成。以0开头 system.out.println(01111);
     *     十进制：由0,1....9组成。默认整数就是十进制  system.out.println(1111);
     *     十六进制：由0,1....9,a,b,c,d,e,f组成 (大小写均可)，以0x开头 system.out.println(0x3c);
     *  补充知识点3:
     *    任意进制的数据到十进制(位权展开法:系数*基数^权次幂之和)：
     *    java 中可以用 << 左移来做幂次方 ^这里表示幂次方
     *      0b111110
     *        =1*2^5 + 1*2^4 + 1*2^3 + 1*2^2 + 1*2^1
     *      0123
     *       =1*8^2 + 2*8^1 + 3*8^0
     *     0x3c
     *      =3*16^1 + 12*16^0
     *       补充知识点3验证:
     *       System.out.println(0b111110 + " " + (1*(2<<5) + 1*2^4 + 1*2^3 + 1*2^2 + 1*2^1));
     *       System.out.println(0123 + " " + (1*8^2 + 2*8^1 + 3*8^0));
     *       System.out.println(0x3c + " " + (3*16^1 + 12*16^0));
     *
     */
    public static void main(String[] args) {
        int a = 3;
        int b = 4;
        // int 占四个字节 ，
        //
        /*
         *   &位与运算符：有0则0
         *      00000000 00000000 00000000 00000011
         *     &00000000 00000000 00000000 00000100
         *      ------------------------------------
         *      00000000 00000000 00000000 00000000
         */
        System.out.println("&位与运算 >>> " + (a & b));
        /*
         *   |位或运算符：有1则1
         *      00000000 00000000 00000000 00000011
         *     |00000000 00000000 00000000 00000100
         *      ------------------------------------
         *      00000000 00000000 00000000 00000111
         */
        System.out.println(a | b);

        /*
         *   ^异或运算符：相同则0，不同则1
         *      00000000 00000000 00000000 00000011
         *     ^00000000 00000000 00000000 00000100
         *      ------------------------------------
         *      00000000 00000000 00000000 00000111
         */
        System.out.println(a ^ b);

        /*
         *   ~取反运算符：0变1，1变0
         *     ~00000000 00000000 00000000 00000100
         *      ------------------------------------
         *      11111111 11111111 11111111 11111011(原码)
         *      10000000 00000000 00000000 00000100(反码)
         *      10000000 00000000 00000000 00000101(补码)
         */
        System.out.println(~b);

        System.out.println(0b10000001);
        // X的原码为10110100B，求反码及补码

        /*
         *  <<：左移运算符 左边最高位丢弃，右边补齐0
         *   +3
         *    00000000 00000000 00000000 00000011
         *  <<
         *    00000000 00000000 00000000 00001100
         *  -3
         *    1 0000011(原码)
         *    1 1111100(反码)
         *    1 1111101(补码)
         *  ---------------
         *    右移两位之后
         *   补码：1 1110100(用上述补码操作 1111 1101 并用1补齐左边)
         *   反码：1 1110011( 补码到反码 低位减1 为0向前借后 2-1=1，一直借   )
         *   原码：1 0001100( 反码到补码 符号位不变 数值位1变0,0变1 )
         */
        System.out.println(-3 << 2);

        /*
         *  >> 右移 最高位是0，左边补0，最高位是1，左边补1
         *   +3
         *    00000000 00000000 00000000 00000011
         *  >> 0000000000 00000000 00000000 000000(11)
         *   -24
         *     00000000 00000000 00000000 00000011
         *
         */
        System.out.println(3 >> 2);
    }
}
