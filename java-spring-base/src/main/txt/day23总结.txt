1:多线程(理解)
	(1)多线程：一个应用程序有多条执行路径
		进程：正在执行的应用程序
		线程：进程的执行单元，执行路径
		单线程：一个应用程序只有一条执行路径
		多线程：一个应用程序有多条执行路径
		并行和并发
		   并行：同时执行 是一种程序运行时的状态 单线程无法达到并行状态
           并发：多个线程被(一个)CPU 轮流切换执行
		多进程的意义?
			提高CPU的使用率
		多线程的意义?
			提高应用程序的使用率
	(2)Java程序的运行原理及JVM的启动是多线程的吗?
		A:Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。
		B:JVM的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。
	(3)多线程的实现方案(自己补齐步骤及代码	掌握)
		// 启动一个线程是start(), run()是线程启动要执行的代码 如果不重写run() 线程就没有可执行的代码 无意义
		A:继承Thread类
          public class A extends Thread {
             @override
             public void run (){
               要执行线程逻辑的代码
             }
          }
          A a = new A();
          a.start();
		B:实现Runnable接口
		public class B implement Runnable {
		     @override
		     public void run(){
		       要执行线程逻辑的代码
		     }
		}
		new Thread(new B()).start();

	(4)线程的调度和优先级问题
		A:线程的调度
			a:分时调度 所有线程轮流使用CPU的使用权 平均分配每个线程的占用CPU的时间片
			b:抢占式调度 (Java采用的是该调度方式)  优先让优先级高使用cpu
		B:获取和设置线程优先级
		    方法  setPriority(int new priority)
		         getPriority()
			a:默认是5
			b:范围是1-10
			注意点 ： 设置了线程的优先级 并不一定说当前线程执行顺序优于其他线程 只是说概率上会大了
	(5)线程的控制(常见方法)
		A:休眠线程 静态方法 在任何范围内都可调用 使当前线程进入阻塞状态 不会释放锁 Thread.sleep(long time) time 毫秒数  1000 = 1s
		B:加入线程 对象方法 new Thread().join()  在线程a中调用线程b的join() 此时线程a进入阻塞 直到线程b 代码逻辑执行结束 线程a才能有执行资格
		C:礼让线程 native() 本地方法 yield() 让出cpu的执行权 回到就绪状态 但有可能下次cpu 又执行到当前线程 依赖CPU时间片
		          具体没啥作用 复杂操作时 可以避免一个线程长时间占用cpu资源
		D:后台线程 对象方法 setDeamon(boolean on) 默认false 后台守护线程 当剩下的线程都是守护线程时JVM退出 例子：坦克大战
		E:终止线程(掌握) 对象方法 stop() 过时 暴力 正在运行线程的直接被终止  、
		                interrupt() 线程中断 清除interrupted status 并不真的中断线程了 通知线程应该中断了 是继续运行还是中断 通知的线程自己处理
		                 抛出InterruptedException 自己处理 正在运行的线程 只是更改标志位状态 不受影响
	(6)线程的生命周期(参照	线程生命周期图解.bmp)
		A:新建：创建线程对象
		B:就绪：有CPU的执行资格 但没执行权
		C:运行：有CPU的执行资格 执行权
		D:阻塞：没有CPU的执行资格 没有执行权
		       正在运行中的线程调用了 sleep() wait() join()--->(5)B  等方法变成阻塞状态
		       等待sleep()休眠时间到 等待notify() notifyAll()唤醒线程（优先级高 概率高） 线程通信
		E:死亡：线程变成垃圾 等待回收
	(7)电影院卖票程序的实现
		A:继承Thread类
		B:实现Runnable接口
		思路 弄一个全局变量100张票 创建一个买票程序  创建一个买票对象 创建n个买票线程 启动线程
	(8)电影院卖票程序出问题
		A:为了更符合真实的场景，加入了休眠100毫秒。
		B:卖票问题
			a:同票多次 CPU操作时原子性
			b:负数票 随机性 延迟性 导致
	(9)多线程安全问题的原因(也是我们以后判断一个程序是否有线程安全问题的依据)
		A:是否有多线程环境
		B:是否有共享数据 （单例模式会有线程安全问题）
		C:是否有多条语句操作共享数据
	(10)同步解决线程安全问题
		A:同步代码块
			synchronized(对象) {
				需要被同步的代码;
			}
			这里的锁对象可以是任意对象。 通过查询spring 源码发现 底层锁对象 大多 Object object = new Object();
			
		B:同步方法
			把同步加在方法上。
			
			这里的锁对象是this
			
		C:静态同步方法
			把同步加在方法上。
			
			这里的锁对象是当前类的字节码文件对象(反射再讲字节码文件对象)
	(11)回顾以前的线程安全的类
		A:StringBuffer  大多数场景用不上 StringBuilder() 线程不安全用的多
		B:Vector 底层是数组 查询快 增删慢 线程安装 效率低 直接放弃
		C:Hashtable
		D:如何把一个线程不安全的集合类变成一个线程安全的集合类
			用Collections工具类的方法即可。
			CopyOnWriteArrayList 线程安全集合
